19. Кратчайшие пути: алгоритм Дейкстры


A. Алгоритм Дейкстры?
ограничение по времени на тест1 second
ограничение по памяти на тест256 МБ
Задан неориентированный взвешенный граф, вершины которого пронумерованы от 1 до n. Ваша задача найти кратчайший путь из вершины 1 в вершину n.

Входные данные
В первой строке содержатся целые числа n и m (2 ≤ n ≤ 10^5,0 ≤ m ≤ 10^5), где n — количество вершин,
а m — количество ребер в графе. Далее в m строках содержатся сами ребра, по одному в строке.
Каждое ребро задается тремя числами ai, bi, wi (1 ≤ ai, bi ≤ n, 1 ≤ wi ≤ 10^6),
где ai, bi — это концы ребра, а wi — его длина.

Граф может содержать кратные ребра и петли.

Выходные данные
Выведите число -1 если пути нет или сам кратчайший путь, если он существует.

#include <vector>
#include <iostream>
#include <map>
#include <set>

int main() {
    int n, m, na, a, b, c, con;
    long long infinite = 1e17;
    std::cin >> n >> m;
    na = 1;
    con = n;
    std::vector<std::vector<int>> v(m, std::vector<int>(3));
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b >> c;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
        v[i][2] = c;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], v[i][2]});
        v1[v[i][1]].push_back({v[i][0], v[i][2]});
    }
    na -= 1;
    con -= 1;
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    if (dist[con] != infinite) {
        while (con != -1) {
            x.push_back(con);
            con = rod[con];
        }
        for (int i = x.size() - 1; i >= 0; i--) {
            std::cout << x[i] + 1 << " ";
        }
    } else {
        std::cout << -1;
    }
}


C. Заправки
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
В стране N городов, некоторые из которых соединены между собой дорогами. Для того, чтобы проехать по одной дороге,
требуется один бак бензина. В каждом городе бак бензина имеет разную стоимость. Вам требуется добраться
из первого города в N-ый, потратив как можно меньшее денег. Покупать бензин впрок нельзя.

Входные данные
В первой строке вводится число N (1≤N≤100), в следующей строке идет N чисел, i-ое из которых задает стоимость бензина
в i-ом городе (всё это целые числа из диапазона от 0 до 100).

Затем идет число M — количество дорог в стране, далее идет описание самих дорог.
Каждая дорога задается двумя числами — номерами городов, которые она соединяет.
Все дороги двухсторонние (то есть по ним можно ездить как в одну, так и в другую сторону),
между двумя городами всегда существует не более одной дороги, не существует дорог, ведущих из города в себя.

Выходные данные
Требуется вывести одно число — суммарную стоимость маршрута или −1, если добраться невозможно.

#include <vector>
#include <iostream>
#include <map>
#include <set>

int main() {
    int n, m, na, a, b, con;
    long long infinite = 1e17;
    std::cin >> n;
    na = 1;
    con = n;
    std::vector<int> vv(n);
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < n; i++) {
        std::cin >> a;
        vv[i] = a;
    }
    std::cin >> m;
    std::vector<std::vector<int>> v(m, std::vector<int>(2));
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], vv[v[i][0]]});
        v1[v[i][1]].push_back({v[i][0], vv[v[i][1]]});
    }
    na -= 1;
    con -= 1;
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    if (dist[con] != infinite) {
        std::cout << dist[con];
    } else {
        std::cout << -1;
    }
}


D. Олимпиада по алхимии
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
В государстве алхимиков есть N населённых пунктов, пронумерованных числами от 1 до N, и M дорог.
Населённые пункты бывают двух типов: деревни и города. Кроме того, в государстве есть одна столица
(она может располагаться как в городе, так и в деревне). Каждая дорога соединяет два населённых пункта, и для проезда
по ней требуется Ti минут. В столице было решено провести 1-ю государственную командную олимпиаду по алхимии.
Для этого во все города из столицы были отправлены гонцы (по одному гонцу на город) с информацией про олимпиаду.

Напишите программу, которая посчитает, в каком порядке и через какое время каждый из гонцов доберётся до своего города.
Считается, что гонец во время пути не спит и нигде не задерживается.

Входные данные
Во входном файле сначала записаны 3 числа N, M, K — количество населенных пунктов, количество дорог
и количество городов (2≤N≤1000, 1≤M≤10000, 1≤K≤N). Далее записан номер столицы C (1≤C≤N).

Следующие K чисел задают номера городов.

Далее следуют M троек чисел Si, Ei, Ti, описывающих дороги: Si и Ei — номера населенных пунктов,
которые соединяет данная дорога, а Ti — время для проезда по ней (1≤Ti≤100).

Гарантируется, что до каждого города из столицы можно добраться по дорогам (возможно, через другие населенные пункты).

Выходные данные
Выведите в выходной файл K пар чисел: для каждого города должен быть выведен его номер и минимальное время,
когда гонец может в нем оказаться (время измеряется в минутах с того момента, как гонцы выехали из столицы).
Пары в выходном файле должны быть упорядочены по времени прибытия гонца.

#include <vector>
#include <iostream>
#include <map>
#include <set>
#include <algorithm>

int main() {
    int n, m, na, a, b, c, k;
    long long infinite = 1e17;
    std::cin >> n >> m >> k >> na;
    na -= 1;
    std::vector<std::vector<int>> v(m, std::vector<int>(3)), otv(k, std::vector<int>(3));
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < k; i++) {
        std::cin >> a;
        otv[i][1] = a - 1;
    }
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b >> c;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
        v[i][2] = c;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], v[i][2]});
        v1[v[i][1]].push_back({v[i][0], v[i][2]});
    }
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    for (int i = 0; i < k; i++) {
        otv[i][0] = dist[otv[i][1]];
    }
    std::sort(begin(otv), end(otv));
    for (int i = 0; i < k; i++) {
        std::cout << otv[i][1] + 1 << " " << otv[i][0] << '\n';
    }
}

--------------------------------------------------------------

20. Дерево отрезков

A. Сумма на отрезке
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Дан массив из N элементов, нужно научиться находить сумму чисел на отрезке.

Входные данные
Первая строка входного файла содержит два целых числа N и K — количество чисел в массиве и количество запросов
(1⩽N⩽100000, 0⩽K⩽100000). Следующие K строк содержат следующие запросы: A i x — присвоить i-му элементу массива
значение x (1⩽i⩽n, 0⩽x⩽109); Q l r — найти сумму чисел в массиве на позициях от l до r (1⩽l⩽r⩽n).
Изначально в массиве живут нули.

Выходные данные
На каждый запрос вида Q l r нужно вывести единственное число — сумму на отрезке.

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>


void build (std::vector<long long> v, long long a, long long tl, long long tr, std::vector<long long>& t) {
    if (tl == tr)
        t[a] = v[tl];
    else {
        long long tm = (tl + tr) / 2;
        build(v, a * 2, tl, tm, t);
        build(v, a * 2 + 1, tm + 1, tr, t);
        t[a] = t[a * 2] + t[a * 2 + 1];
    }
}

long long sum (long long a, long long tl, long long tr, long long l, long long r, std::vector<long long>& t) {
    if (l > r)
        return 0;
    if (l == tl && r == tr)
        return t[a];
    long long tm = (tl + tr) / 2;
    return sum(a * 2, tl, tm, l, std::min(r, tm), t)
        + sum(a * 2 + 1, tm + 1, tr, std::max(l, tm + 1), r, t);
}

void update (long long a, long long tl, long long tr, long long pos, long long n, std::vector<long long>& t) {
    if (tl == tr)
        t[a] = n;
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(a * 2, tl, tm, pos, n, t);
        else
            update(a * 2 + 1, tm + 1, tr, pos, n, t);
        t[a] = t[a * 2] + t[a * 2 + 1];
    }
}


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long n, k, a, b, c;
    char s;
    std::cin >> n >> k;
    std::vector<long long> v(n), t(n * 4);
    for (int i = 0; i < k; i++) {
        std::cin >> s;
        if (s == 'A') {
            std::cin >> a >> b;
            v[a - 1] = b;
            update(1, 0, n - 1, a - 1, b, t);
        } else {
            std::cin >> a >> b;
            std::cout << sum(1, 0, n - 1, a - 1, b - 1, t) << '\n';
        }
    }
    /*
    for (int i = 0; i < n; i++) {
        std::cout << v[i] << " ";
    }
    std::cout << '\n';
    for (int i = 0; i < n * 4; i++) {
        std::cout << t[i] << " ";
    }
    */
}


B. RMQ
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Реализуйте структуру данных, которая на данном массиве из N целых чисел позволяет узнать максимальное значение
на этом массиве.

Входные данные
В первой строке вводится натуральное число N (1≤N≤10^5) – количество элементов в массиве. В следующей строке содержатся
N целых чисел, не превосходящих по модулю 10^9 – элементы массива гарантируется. Далее идет число K (0≤K≤10^5) –
количество запросов к структуре данных. Каждая из следующих K строк содержит два целых числа l и r (1≤l≤r≤N) –
левую и правую границы отрезка в массиве для данного запроса.

Выходные данные
Для каждого из запросов выведите два числа: наибольшее значение среди элементов массива на отрезке от l до r.

#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(100000), t(400000, -1000000001);

void build(int a, int tl, int tr) {
    if (tl == tr) {
        t[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        t[a] = std::max(t[a * 2], t[a * 2 + 1]);
    }
}

int maxx(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return -1000000001;
    if (l <= tl && tr <= r)
        return t[a];
    int tm = (tl + tr) / 2;
    return std::max(maxx(a * 2, tl, tm, l, r)
        , maxx(a * 2 + 1, tm + 1, tr, l, r));
}

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int n, k, a, b;
    std::cin >> n;

    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }
    build(1, 0, n - 1);
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> a >> b;
        std::cout << maxx(1, 0, n - 1, a - 1, b - 1) << '\n';
    }
/*
    for (int i = 0; i < n; i++) {
        std::cout << v[i] << " ";
    }
    std::cout << '\n';
    for (int i = 0; i < n * 4; i++) {
        std::cout << t[i] << " ";
    }
*/
}


C. НОД на подотрезках с изменением элемента
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Реализуйте эффективную структуру данных, позволяющую изменять элементы массивы и вычислять НОД нескольких
подряд идущих элементов.

Входные данные
В первой строке вводится одно натуральное число N (1≤N≤100000) – количество чисел в массиве.

Во второй строке вводятся N чисел от 0 до 100000 – элементы массива.

В третьей строке вводится одно натуральное число M (1≤M≤30000) – количество запросов.

Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса
(s – вычислить НОД, u – обновить значение элемента). Следом за s вводятся два числа – номера левой и правой границы
отрезка. Следом за u вводятся два числа – номер элемента и его новое значение.

Выходные данные
Для каждого запроса s выведите результат. Все числа выводите в одну строку через пробел.

#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> v(100000), t(400000, 0);

int nod(int n, int m) {
    if (n == m) {
        return n;
    }
    if (n == 0) {
        return(m);
    }
    return nod(m % n, n);
}

void build(int a, int tl, int tr) {
    if (tl == tr) {
        t[a] = v[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a * 2, tl, tm);
        build(a * 2 + 1, tm + 1, tr);
        t[a] = nod(t[a * 2], t[a * 2 + 1]);
    }
}

int nodd(int a, int tl, int tr, int l, int r) {
    if (r < tl || l > tr)
        return 0;
    if (l <= tl && tr <= r)
        return t[a];
    int tm = (tl + tr) / 2;
    return nod(nodd(a * 2, tl, tm, l, r)
        , nodd(a * 2 + 1, tm + 1, tr, l, r));
}

void update (int a, int tl, int tr, int pos, int n) {
    if (tl == tr)
        t[a] = n;
    else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(a * 2, tl, tm, pos, n);
        else
            update(a * 2 + 1, tm + 1, tr, pos, n);
        t[a] = nod(t[a * 2], t[a * 2 + 1]);
    }
}

int main() {
    // std::ios::sync_with_stdio(0);
    // std::cin.tie(0);
    long long n, k, a, b, c;
    char s;
    std::cin >> n;
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }
    build(1, 0, n - 1);
    std::cin >> k;
    for (int i = 0; i < k; i++) {
        std::cin >> s;
        if (s == 'u') {
            std::cin >> a >> b;
            v[a - 1] = b;
            update(1, 0, n - 1, a - 1, b);
        } else {
            std::cin >> a >> b;
            std::cout << nodd(1, 0, n - 1, a - 1, b - 1) << " ";
        }
    }
    /*
    for (int i = 0; i < n; i++) {
        std::cout << v[i] << " ";
    }
    std::cout << '\n';
    for (int i = 0; i < n * 4; i++) {
        std::cout << t[i] << " ";
    }
    */
}

----------------------------------------------------------

21. Топсорт и КСС

A. Топологическая сортировка
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Дан ориентированный невзвешенный граф. Необходимо построить его топологическую сортировку.

Входные данные
В первой строке входного файла даны два натуральных числа n и m (1≤n≤100000, 0≤m≤100000) — число вершин и рёбер
в графе соответственно. Далее в m строках перечислены рёбра графа. Каждое ребро задаётся парой чисел —
номерами начальной и конечной вершин соответственно.

Выходные данные
Выведите любую топологическую сортировку графа в виде последовательности номеров вершин.
Если граф невозможно топологически отсортировать, выведите −1.

#include <iostream>
#include <vector>

void DFS(int x, std::vector<int>& u, std::vector<std::vector<int>>& v1,
         int rod, int& a, std::vector<int>& otv) {
    u[x] = 1;
    for (int i = 0; i < v1[x].size(); i++) {
        if (u[v1[x][i]] == 0) {
            DFS(v1[x][i], u, v1, x, a, otv);
        } else {
            if (u[v1[x][i]] == 1) {
                a = 1;
            }
        }
    }
    otv.push_back(x + 1);
    u[x] = 2;
}

int main() {
    int n, m, a, b;
    std::cin >> n >> m;
    std::vector<std::vector<int>> v(n, std::vector<int>(2)), v1(n);  // ребра, топсорт
    std::vector<int> u(n), otv;  // посещенные вершины, ответ
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back(v[i][1]);
    }
    a = 0;
    for (int i = 0; i < n; i++) {
        if (u[i] == 0) {
            DFS(i, u, v1, n, a, otv);
        }
    }
    if (a == 0) {
        for (int i = n - 1; i > -1; i--) {
            std::cout << otv[i] << " ";
        }
    } else {
        std::cout << -1;
    }
}


C. Топологическая сортировка
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Задан ориентированный ациклический граф с n вершинами и m ребрами. Также задана перестановка вершин графа.
Необходимо проверить, является ли данная перестановка топологической сортировкой.

Входные данные
В первой строке даны два числа n и m — количество вершин и ребер в графе соответственно (1≤n,m≤10^5).
В следующих m строках заданы пары чисел ui,vi, означающие, что в графе есть ребро из вершины ui в вершину vi.
В последней строке задана перестановка из n элементов.

Выходные данные
Выведите «YES» (без кавычек), если данная перестановка является топологической сортировкой и «NO» в противном случае.

#include <iostream>
#include <vector>

int main() {
    int n, m, a, b;
    std::cin >> n >> m;
    std::vector<std::vector<int>> v(m, std::vector<int>(2)), v1(m);  // ребра, список родителей вершины
    std::vector<int> u(n), ot(n);  // посещенные вершины, якобы топсорт данный нам
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b;
        v[i][0] = --a;
        v[i][1] = --b;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][1]].push_back(v[i][0]);
    }

    for (int i = 0; i < n; i++) {
        std::cin >> a;
        ot[i] = --a;
    }
    b = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < v1[ot[i]].size(); j++) {
            if (u[v1[ot[i]][j]] == 0) {
                b = 1;
                break;
            }
        }
        u[ot[i]] = 1;
        if (b == 1) {
            break;
        }
    }
    if (b == 0) {
        std::cout << "YES";
    } else {
        std::cout << "NO";
    }
}

-------------------------------------------------------------------------------

Хеши

C. Строчечки
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
Мальчик Кирилл написал однажды на листе бумаги строчку, состоящую из больших и маленьких латинских букв,
а после этого ушел играть в футбол. Когда он вернулся, то обнаружил, что его друг Дима написал под его строкой
еще одну строчку такой же длины. Дима утверждает, что свою строчку он получил циклическим сдвигом строки Кирилла
на несколько шагов вправо (циклический сдвиг строки «abcde» на 2 позиции вправо даст строку «deabc»).
Однако Дима известен тем, что может случайно ошибиться в большом количестве вычислений,
поэтому Кирилл в растерянности – верить ли Диме? Помогите ему! По данным строкам выведите минимальный возможный размер
сдвига или −1, если Дима ошибся.

Входные данные
Первые две строки входных данных содержат строки Кирилла и Димы, соответственно.
Длины строк одинаковы, не превышают 10^6 и не равны 0.

Выходные данные
Выведите единственное число – ответ на вопрос задачи.

#include <iostream>
#include <vector>
#include <cmath>

const long long k = 89, mod = 1e9+7;

long long xesh(std::string s) {
    long long h = 0;
    for (char c : s) {
        h = (h * k + int (c - 'A' + 1)) % mod;
    }
    return h;
}

int main() {
    long long s1, t1;
    std::string s, t;
    std::cin >> s >> t;
    int a;
    long long po;
    a = t.size();
    po = 1;
    for (int i = 0; i < a - 1; i++) {
        po = (po * k) % mod;
    }
    t1 = xesh(t);
    s1 = xesh(s);
    if (s1 == t1) {
        std::cout << 0;
        return 0;
    }
    for (int i = 0; i < a - 1; i++) {
        s1 = (s1 - int (s[i] - 'A' + 1) * po % mod + mod) % mod;
        s1 = s1 * k % mod;
        s1 = (s1 + int (s[i] - 'A' + 1)) % mod;
        if (s1 == t1) {
            std::cout << a - i - 1;
            return 0;
        }
    }
    std::cout << -1;
}


D. Поиск подстроки (1 балл)
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Найти все вхождения строки T в строку S.

Входные данные
Первые две строки входных данных содержат строки S и T, соответственно. Длины строк больше 0 и меньше 500000,
строки содержат только строчные латинские буквы.

Выходные данные
Выведите номера символов, начиная с которых строка T входит в строку S, в порядке возрастания.

#include <iostream>
#include <vector>
#include <cmath>

const long long k = 59, mod = 1e9+6;
long long x;

long long xesh(std::string s) {
    long long h = 0;
    for (char c : s) {
        h = (h * k + int (c - 'a' + 1)) % mod;
    }
    // std::cout << "hash: " << h << '\n';
    return h;
}

int main() {
    long long s1, t1;
    std::string s, t, ss;
    std::cin >> s >> t;
    int a;
    long long po;
    a = t.size();
    if (a > s.size()) {
        return 0;
    }
    po = 1;
    for (int i = 0; i < a - 1; i++) {
        po = (po * k) % mod;
    }
    t1 = xesh(t);
    std::copy(s.begin(), s.begin() + a, inserter(ss, ss.begin()));
    s1 = xesh(ss);
    if (s1 == t1) {
        std::cout << 0 << ' ';
    }
    for (int i = 0; i < s.size() - a; i++) {
        s1 = (s1 - int (s[i] - 'a' + 1) * po + mod) % mod;
        // std::cout << i << ": " << s1 << ' ';
        s1 = s1 * k % mod;
        // std::cout << s1 << ' ';
        s1 = (s1 + int (s[i + a] - 'a' + 1)) % mod;
        // std::cout << s1 << '\n';
        if (s1 == t1) {
            std::cout << i + 1 << ' ';
        }
    }
}

-----------------------------------------------------------------

23. Задачи на графы

C. От матрицы смежности к спискам смежности
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Простой ориентированный граф задан матрицей смежности. Выведите его представление в виде списков смежности.

Входные данные
В первой строке файла находится число N — количество вершин графа (1⩽N⩽100).
Во второй строке и далее — матрица смежности. Гарантируется, что граф не содержит петель.

Выходные данные
Выведите N строк — списки смежности графа. В i-й строке сначала выведите количество исходящих из i-й вершины рёбер,
а затем — номера вершин, в которые эти рёбра идут, упорядоченные по возрастанию.

#include <iostream>
#include <vector>
#include <cmath>

int main() {
    int n, a, b;
    std::cin >> n;
    std::vector<std::vector<int>> vec(n, std::vector<int>(n));
    std::vector<int> otv(n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> a;
            vec[i][j] = a;
        }
    }
    for (int i = 0; i < n; i++) {
        a = 0;
        b = 0;
        for (int j = 0; j < n; j++) {
            if (vec[i][j] == 1) {
                a += vec[i][j];
                otv[b] = j + 1;
                b += 1;
            }
        }
        std::cout << a;
        for (int j = 0; j < a; j++) {
            std::cout << ' ' << otv[j];
        }
        std::cout << '\n';
    }
}


D. От списков смежности к матрице смежности
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт

Входные данные
В первой строке входного файла содержится число N — количество вершин (1⩽N⩽100). Далее идут N строк.
В i-й строке содержится описание всех рёбер, исходящих из i-й вершины. Описание начинается количеством исходящих рёбер.
Далее следуют номера вершин, в которые эти рёбра идут. Все вершины нумеруются натуральными числами от 1 до N.
Гарантируется, что i-й список смежности не содержит числа i, а также все списки не содержат повторяющихся чисел.

Выходные данные
Выведите матрицу смежности ориентированного графа.

#include <iostream>
#include <vector>
#include <cmath>

int main() {
    int n, m, a;
    std::cin >> n;
    std::vector<std::vector<int>> vec(n, std::vector<int>(n));
    for (int i = 0; i < n; i++) {
        std::cin >> m;
        for (int j = 0; j < m; j++) {
            std::cin >> a;
            vec[i][a - 1] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << vec[i][j] << ' ';
        }
    std::cout << '\n';
    }
}

-------------------------------------------------------------------------

Интерактивки

A. Угадай число
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 512 МБ
Это интерактивная задача. В процессе тестирования программа участника взаимодействует с программой жюри
с использованием стандартных потоков ввода/вывода.

Программа жюри загадала число от 1 до n, цель программы участника — отгадать, задав не более чем 30 вопросов.
Для этого программа участника сообщает свои догадки программе жюри, а программа жюри отвечает,
является ли загаданное число бóльшим, меньшим или равным сделанной догадке.

Протокол взаимодействия
Сначала необходимо прочитать из стандартного потока ввода число n (1 ≤ n ≤ 10^9). Затем протокол общения следующий:
требуется вывести в стандартный поток вывода одну строку, содержащую целое число — свою догадку о загаданном числе.

После этого необходимо считать из стандартного потока ввода одно число: сообщение программы жюри.
Возможны следующие сообщения:
«1» — загаданное число больше последней догадки;
«-1» — загаданное число меньше последней догадки;
«0» — последняя догадка верна. Считав 0, ваша программа должна завершиться.

#include <iostream>
#include <vector>

int main() {
    // std::ios::sync_with_stdio(0);
    // std::cin.tie(0);
    int n, L, R, M, otv;
    std::cin >> n;
    L = 1;
    R = n + 1;
    while (true) {
        M = (L + R) / 2;
        std::cout << M << '\n';
        std::cin >> otv;
        if (otv == -1) {
            R = M;
            continue;
        }
        if (otv == 1) {
            L = M;
            continue;
        }
        break;
    }
}


C. Опасные игры
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Это интерактивная задача.

Однажды утром Вай получила посылку от Джинкс, где обнаружила радиопередатчик и схематический рисунок бомбы с подписью
«НАЙДИ МЕНЯ». Передатчик, как оказалось, указывает направление до бомбы, но может сделать это ограниченное число раз,
о чем многозначительно говорит все уменьшающаяся красная цифра на экране.

Вай знает, что бомба спрятана где-то в городе на участке размером n×n. Она может встать в любую клетку участка и
активировать передатчик, который сообщит, где относительно неё находится взрывчатка. Клетки задаются координатами,
первая координата — номер строки сверху-вниз, вторая — номер столбца слева-направо. Если Вай уже в клетке с бомбой,
то передатчик выдаст «OK», и бомба будет деактивирована, иначе выдаст направление, в котором находится бомба
относительно текущей позиции Вай.

Направление может принимать одно из значений «N», «S», «W», «E», «NW», «NE», «SW» или «SE». 'N' означает вверх,
'S' — вниз, 'W' — влево, 'E' — вправо, а их комбинация, соответственно, — комбинацию из двух направлений.
К примеру, если ответ будет «NE», то это значит, что клетка с бомбой находится сверху справа от текущей.

Протокол взаимодействия
В первой строке интерактор сообщает вашей программе целое число n — длину стороны поля, на котором ведется поиск
(1⩽n⩽10^9).

Далее ваша программа должна следовать протоколу взаимодействия с интерактором. Весь протокол взаимодействия разбивается
на запросы, которые совершает ваша программа, и ответы на них, которые дает интерактор.

Ваша программа должна передавать интерактору запросы в формате «x y» (без кавычек), где x и y —
координаты интересующей вас клетки по вертикали и горизонтали, соответственно (1⩽x,y,⩽n).
Каждый запрос должен быть выведен на отдельной строке и должен заканчиваться сбросом буфера потока вывода
(cout.flush() в C++, System.out.flush() в Java, sys.stdout.flush() в Python).

В ответ на запрос (x,y) интерактор сообщит относительное положение искомой клетки поля на отдельной строке.
Если искомая клетка не совпадает с (x,y), ответ интерактора будет являться конкатенацией двух частей,
первая из которых может быть равна 'N', 'S' или пустой строке, а вторая — 'W', 'E' или пустой строке.
Каждый символ отвечает за положение искомой клетки относительно (x,y).
Символ 'N' означает, что искомая клетка находится выше, 'S' — ниже, 'W' — левее, 'E' — правее.

Если запросом (x,y) ваша программа угадывает искомую клетку, интерактор отвечает в новой строке словом «OK»
(без кавычек) и завершается. Считав такой ответ, ваша программа тоже должна завершиться, иначе может быть получен
вердикт TL или IL.

Всего ваша программа может сделать не более 50 запросов к интерактору. Как только ваша программа превышает это
ограничение, интерактор завершается с ошибкой WA. Если ваша программа при этом не завершается, может быть получен
вердикт TL или IL.

#include <iostream>
#include <vector>

int main() {
    // std::ios::sync_with_stdio(0);
    // std::cin.tie(0);
    int n, L, LL, R, RR, M, MM;
    std::string otv;
    std::cin >> n;
    L = 1;
    R = n + 1;
    LL = 1;
    RR = n + 1;
    while (true) {
        M = (L + R) / 2;
        MM = (LL + RR) / 2;
        std::cout << MM << ' ' << M << '\n';
        std::cin >> otv;
        if (otv == "N") {
            RR = MM;
            continue;
        }
        if (otv == "S") {
            LL = MM;
            continue;
        }
        if (otv == "W") {
            R = M;
            continue;
        }
        if (otv == "E") {
            L = M;
            continue;
        }
        if (otv == "NW") {
            RR = MM;
            R = M;
            continue;
        }
        if (otv == "NE") {
            RR = MM;
            L = M;
            continue;
        }
        if (otv == "SW") {
            LL = MM;
            R = M;
            continue;
        }
        if (otv == "SE") {
            LL = MM;
            L = M;
            continue;
        }
        break;
    }
}

----------------------------------------------------------------

Тренировочный контест-1

A. Прогрессивный квадрат
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Прогрессивный квадрат размера n — это матрица размера n×n. Максим выбирает три натуральных числа a1,1, c и d и строит
прогрессивный квадрат по следующим правилам:

ai+1,j = ai,j+c
ai,j+1 = ai,j+d
Например, если n=3, a1,1 = 1, c=2 и d=3, то прогрессивный квадрат выглядит следующим образом:
1 4 7
3 6 9
5 8 11
В прошлом месяце Максим построил прогрессивный квадрат и запомнил значения n, c и d. Недавно он нашёл массив b из n^2
целых чисел, идущих в случайном порядке и хочет убедиться, что эти элементы являются элементами того самого квадрата.

Можно показать, что при любых значениях n, a1,1, c и d существует ровно один прогрессивный квадрат,
удовлетворяющий всем правилам.

Входные данные
В первой строке задано целое число t (1≤t≤10^4) — количество наборов входных данных.

Первая строка каждого набора содержит три целых числа n, c и d (2≤n≤500, 1≤c,d≤10^6) — размер квадрата и значения
c и d, описанные в условии.

Вторая строка каждого набора содержит n⋅n целых чисел b1,b2,…,bn⋅n (1≤bi≤10^9) — элементы, которые нашёл Максим.

Гарантируется, что сумма n2 по всем наборам входных данных не превосходит 25⋅10^4.

Выходные данные
Для каждого набора входных данных в отдельной строке выведите «YES», если прогрессивный квадрат для данных n, c и d
может быть составлен из элементов массива a, в противном случае выведите «NO».

Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «yEs», «yes», «Yes» и «YES»
будут приняты как положительный ответ.

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int a, n, c, d, e, mi;
    std::vector<int> b, bb;
    std::cin >> a;
    for (int _ = 0; _ < a; _++) {
        mi = 1000000000;
        std::cin >> n >> c >> d;
        for (int i = 0; i < n * n; i++) {
            std::cin >> e;
            b.push_back(e);
            if (e < mi) {
                mi = e;
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                bb.push_back(mi + i * c + j * d);
            }
        }
        std::sort(begin(b), end(b));
        std::sort(begin(bb), end(bb));
        if (b == bb) {
            std::cout << "YES" << '\n';
        } else {
            std::cout << "NO" << '\n';
        }
        b.clear();
        bb.clear();
    }
}


B. Обитатель морских глубин
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
На исследование глубин океана отправились n кораблей, корабли пронумерованы от 1 до n и следуют друг за другом
в порядке возрастания номеров, i-й корабль имеет прочность ai.

На корабли напал Кракен, он атакует корабли k раз в определённом порядке. Сначала он атакует первый из кораблей,
потом последний, потом снова первый и так далее.

Каждая атака Кракена снижает прочность корабля на 1. Когда прочность корабля опускается до 0, он тонет и больше не
подвергается атакам (таким образом корабль перестаёт быть первым или последним, а Кракен атакует только те корабли,
которые ещё не утонули). Если все корабли оказались потоплены, Кракену нечего атаковать, и он уплывает.

Например, если n=4, k=5 и a=[1,2,4,3], то произойдёт следующее:
Кракен атакует первый корабль, его прочность стала нулевой и теперь a=[2,4,3];
Кракен атакует последний корабль, теперь a=[2,4,2];
Кракен атакует первый корабль, теперь a=[1,4,2];
Кракен атакует последний корабль, теперь a=[1,4,1];
Кракен атакует первый корабль, его прочность стала нулевой и теперь a=[4,1].
Сколько кораблей оказались потоплены после нападения Кракена?

Входные данные
В первой строке задано целое число t (1≤t≤10^4) — количество наборов входных данных.

Первая строка каждого набора содержит два целых числа n и k (1≤n≤2⋅10^5, 1≤k≤1015) — количество кораблей,
а так же сколько раз Кракен будет атаковать корабли.

Вторая строка каждого набора содержит n целых чисел a1,a2,…,an (1≤ai≤10^9) — прочности кораблей.

Гарантируется, что сумма n по всем наборам входных данных не превосходит 2⋅10^5.

Выходные данные
Для каждого набора входных данных в отдельной строке выведите количество потопленных Кракеном кораблей.

#include <iostream>
#include <vector>

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    long long b, c, n, k, L, R;
    std::cin >> b;
    for (int _ = 0; _ < b; _++) {
        std::cin >> n >> k;
        std::vector<long long> a(n);
        L = 0;
        R = n - 1;
        for (int i = 0; i < n; i++) {
            std::cin >> a[i];
        }
        for (long long i = 0; i < k; i++) {
            if (L > R) {
                break;
            }
            if (L == R) {
                if (k - i >= a[L]) {
                    L += 1;
                }
                break;
            }
            if (k - i >= a[L] * 2 || k - i >= a[R] * 2) {
                if (a[L] < a[R]) {
                    a[R] -= a[L];
                    i += 2 * a[L] - 1;
                    L += 1;
                } else {
                    if (a[R] < a[L]) {
                        a[L] -= a[R];
                        i += 2 * a[R] - 1;
                        R -= 1;
                    } else {
                        i += 2 * a[L] - 1;
                        L += 1;
                        R -= 1;
                    }
                }
            } else {
                if (k - i + 1 >= a[L] * 2) {
                    L += 1;
                }
                break;
            }
        }
        std::cout << n - R + L - 1 << '\n';
    }
}

-------------------------------------------------------------

Тренировочный контест-2

A. Сделай сумму кратной 3
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Вам дан массив a1,a2,…,an.

За один ход можно выполнить любую из двух операций:
Выбрать элемент из массива и удалить его из массива. В результате длина массива уменьшается на 1;
Выбрать элемент из массива и увеличить его значение на 1.
Вы можете выполнять произвольное количество ходов. Если текущий массив оказался пустым, то больше ходов выполнять нельзя.

Ваша задача — найти минимальное количество ходов, которые необходимо выполнить, чтобы сумма элементов массива a
стала делиться на 3. Возможно, вам понадобится 0 ходов.

Обратите внимание, что сумма элементов пустого массива (массива длины 0) равна 0.

Входные данные
Первая строка ввода содержит одно целое число t (1≤t≤10^4) — количество наборов входных данных.

Первая строка каждого набора входных данных содержит одно целое число n (1≤n≤10^5).

Вторая строка каждого набора входных данных содержит n целых чисел a1,a2,…,an (1≤ai≤10^4).

Сумма n по всем наборам входных данных не превышает 2⋅10^5.

Выходные данные
Для каждого набора входных данных выведите одно целое число: минимальное количество ходов.

#include <iostream>
#include <vector>

int main() {
    int a, b, c, d, e;
    std::cin >> a;
    std::vector<int> v(a);
    for (int i = 0; i < a; i++) {
        std::cin >> b;
        e = 0;
        d = 0;
        for (int j = 0; j < b; j++) {
            std::cin >> c;
            d += c;
            if (c % 3 == 1) {
                e = 1;
            }
        }
        if (d % 3 == 0) {
            v[i] = 0;
        } else {
        if ((d % 3 == 1 && e == 1) || (d % 3 == 2)) {
            v[i] = 1;
        } else {
            v[i] = 2;
        }
        }
    }
    for (int i = 0; i < a; i++) {
        std::cout << v[i] << '\n';
    }
}


D. Еще одна задача о монетах
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
У вас есть 5 различных типов монет, каждый из которых имеет значение равное одному из первых 5 треугольных чисел:
1, 3, 6, 10 и 15. Все типы монет имеются в неограниченном количестве. Ваша задача — определить, какого минимального
количества монет достаточно, чтобы набрать сумму ровно n.
Можно показать, что ответ всегда существует.

Входные данные
В первой строке находится одно целое число t (1≤t≤10^4) — количество наборов входных данных.
Далее следует описание наборов входных данных.

В единственной строке каждого набора входных данных содержится одно целое число n (1≤n≤10^9) — требуемое значение.

Выходные данные
Для каждого набора входных данных выведите одно число — минимальное необходимое число монет.

#include <iostream>
#include <vector>

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int a, b, c;
    std::vector<int> v{0, 1, 2, 1, 2, 3, 1, 2, 3, 2,
                       1, 2, 2, 2, 3, 1, 2, 3, 2, 3,
                       2, 2, 3, 3, 3, 2, 3, 3, 3, 4};
    std::cin >> c;
    for (int i = 0; i < c; i++) {
        std::cin >> a;
        if (a >= 30) {
            b = a / 15 - 1;
            a = a % 15 + 15;
        } else {
            b = 0;
        }
        std::cout << b + v[a] << '\n';
    }
}

---------------------------------------------------------------------------

Тренировочный контест-4

A. Последовательность сравнений
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Когда-то у Пети был массив целых чисел a длины n. Но со временем сам массив был утерян, а остался только n−1 результат
сравнений соседних элементов массива. Другими словами, для каждого i от 1 до n−1, Петя знает, какое из следующих
трех условий выполняется:
ai<ai+1;
ai=ai+1;
ai>ai+1.
Пете стало интересно, можно ли однозначно определить результат сравнения a1 и an.
Ваша задача помочь Пете определить результат сравнения a1 и an или сообщить, что результат невозможно определить
однозначно.

Входные данные
Первая строка содержит одно целое число t (1≤t≤500) — количество наборов входных данных.
Единственная строка набора входных данных содержит строку s (1≤|s|≤100), где si это:
<, если ai<ai+1;
>, если ai>ai+1;
=, если ai=ai+1.

Выходные данные
Для каждого набора входных данных выведите единственную строку равную:
<, если a1<an;
>, если a1>an;
=, если a1=an;
?, если невозможно однозначно определить результат сравнения.

#include <iostream>
#include <vector>
#include <sstream>

int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int t, x;
    std::string s;
    std::cin >> t;
    getline(std::cin, s);
    for (int i = 0; i < t; i++) {
        getline(std::cin, s);

        x = 0;
        for (int j = 0; j < s.size(); j++) {
            if (s[j] == '<') {
                if (x == 1) {
                    x = -2;
                    break;
                } else {
                    x = -1;
                }
            } else {
                if (s[j] == '>') {
                    if (x == -1) {
                        x = -2;
                        break;
                    } else {
                        x = 1;
                    }
                }
            }
        }

        if (x == 1) {
            std::cout << '>' << '\n';
        } else {
        if (x == 0) {
            std::cout << '=' << '\n';
        } else {
        if (x == -1) {
            std::cout << '<' << '\n';
        } else {
            std::cout << '?' << '\n';
        }
        }
        }
    }
}


B. Эпический роман
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт
Алекс купил новый роман, изданный в n томах. Он прочитал все тома друг за другом, потратив на каждый несколько
(один или более) полных дней. Другими словами, в первый день он читал первый том, и каждый следующий день он читал
либо тоже самый том, что и днем ранее, либо следующий.

Пусть vi — это номер тома, который Алекс читал в i-й день. Ниже представлены некоторые примеры возможных ситуаций:
вполне возможна ситуация, что v1=1, v2=1, v3=2, v4=3, v5=3. То есть Алекс потратил два дня (1-й и 2-й) на первый том,
один день (3-й) на второй том и два дня (4-й и 5-й) на третий том;
ситуация v1=2, v2=2, v3=3 невозможна, так как Алекс начал чтение с первого тома (таким образом, v1 не может быть ни
чем кроме 1);
ситуация v1=1, v2=2, v3=3, v4=1 невозможна, так как Алекс не вернется к чтению первого тома после чтения третьего;
ситуация v1=1, v2=3 невозможна, так как Алекс не пропускает тома.
Вы знаете, что Алекс читал том va в день a и том vc в день c. Теперь вы хотите угадать, какой том он читал в день b,
что находится между днями a и c (то есть, a<b<c). Возможно, однозначного ответа нет, а потому вас устроит
любой подходящий по номеру том (т.е. выберете такое значение vb, что возможна ситуация, когда Алекс читал том va
в день a, том vb в день b и том vc в день c).

Входные данные
Во входных данных заданы несколько наборов входных данных. В первой строке задано одно целое число t (1≤t≤100) —
количество наборов входных данных. Далее следуют сами наборы входных данных.
В первой строке каждого набора задано одно целое число n (1≤n≤100) — количество томов, из которых состоит роман.
Во второй строке каждого набора заданы два целых числа a и va (1≤a≤98; 1≤va≤a) означающих, что Алекс читал том va
в день a.
В третьей строке каждого набора заданы два целых числа c и vc (a+2≤c≤100; va≤vc≤c) означающих, что Алекс читал том vc
в день c.
В четвертой строке каждого набора задано одно целое число b (a<b<c) — интересующий вас день.
Гарантируется, что входные данные не противоречивы, то есть Алекс мог читать том va в день a и том vc в день c.

Выходные данные
Для каждого набора входных данных, выведите номер тома, который Алекс мог читать в день b.
Если существует несколько ответов, выведите любой из них.

#include <iostream>
#include <vector>
#include <sstream>


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    int t, r0, r1, a, ua, b, ub, c, uc;
    std::cin >> t;
    for (int i = 0; i < t; i++) {
        std::cin >> a;
        std::cin >> a;
        std::cin >> ua;
        std::cin >> c;
        std::cin >> uc;
        std::cin >> b;
        r0 = b - a;
        r1 = uc - ua;
        if (r1 < r0) {
            std::cout << uc << '\n';
        } else {
            std::cout << ua + r0 << '\n';
        }
    }
}

-----------------------------------------------------------------------

A. Векторы
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Даны два ненулевых вектора. Требуется вычислить:
Длину первого и второго вектора (два числа)
Вектор, образованный сложением данных двух векторов
Скалярное и векторное произведения данных векторов
Площадь треугольника, построенного из этих векторов

Входные данные
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10000, —
координаты начала и конца первого вектора, затем второго.

Выходные данные
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10^−9.

#include <iostream>
#include <cmath>
#include <iomanip>

float S(int ax, int ay, int bx, int by, int cx, int cy) {
    float s;
    s = ((cx - ax) * (by - ay) - (bx - ax) * (cy - ay)) / 2.0;
    return s;
}

int main() {
    float s;
    int ax, ay, bx, by, cx, cy;
    std::cin >> cx >> cy >> ax >> ay;
    ax -= cx;
    ay -= cy;
    std::cin >> cx >> cy >> bx >> by;
    bx -= cx;
    by -= cy;
    cx = 0;
    cy = 0;
    if (ax * ax + ay * ay >= 0) {
        std::cout << std::setprecision(19) << sqrt(ax * ax + ay * ay) << ' ';
    } else {
        std::cout << std::setprecision(19) << sqrt(-(ax * ax + ay * ay)) << ' ';
    }
    if (bx * bx + by * by >= 0) {
        std::cout << std::setprecision(19) << sqrt(bx * bx + by * by) << '\n';
    } else {
        std::cout << std::setprecision(19) << sqrt(-(bx * bx + by * by)) << '\n';
    }
    std::cout << std::setprecision(19) << ax + bx << ' ' << ay + by << '\n';
    std::cout << std::setprecision(19) << ax * bx + ay * by;
    s = S(cx, cy, ax, ay, bx, by);
    std::cout << ' ' << std::setprecision(19) << S(cx, cy, bx, by, ax, ay) * 2 << '\n';
    if (s >= 0) {
        std::cout << std::setprecision(19) << s;
    } else {
        std::cout << std::setprecision(19) << -s;
    }
}


B. Площадь треугольника
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт

Входные данные
Шесть чисел – координаты трёх вершин треугольника.

Выходные данные
Одно число – величина площади треугольника.

#include <iostream>
// #include <vector>

float S(int ax, int ay, int bx, int by, int cx, int cy) {
    float s;
    s = ((cx - ax) * (by - ay) - (bx - ax) * (cy - ay)) / 2.0;
    if (s >= 0) {
        return s;
    } else {
        return -s;
    }
}

int main() {
    int ax, ay, bx, by, cx, cy;
    std::cin >> ax >> ay >> bx >> by >> cx >> cy;
    std::cout << S(ax, ay, bx, by, cx, cy);
}

--------------------------------------------------------------------

Олимпиада-зачет!

A. Ресурсы
ограничение по времени на тест 2 секунды
ограничение по памяти на тест 512 мегабайт
Рома играет в настольную игру. В этой игре есть n типов ресурсов. Сейчас у Ромы есть ai единиц i-го ресурса.
Он посчитал, что для того, чтобы выиграть на этом ходу, ему нужно bi единиц i-го ресурса. В игре можно обменивать
ресурсы в банке по курсу 3:1, то есть за три единицы одного ресурса можно получить одну единицу любого другого ресурса
(обратите внимание, что все три единицы ресурсов, которые отдаются в банк, должны быть одного типа).
Помогите Роме узнать, может ли он выиграть на этом ходу.

Входные данные
Первая строка содержит число n (1≤n≤100). Вторая строка содержит n чисел ai (0≤ai≤100).
Третья строка содержит n чисел bi (0≤bi≤100).

Выходные данные
Выведите Yes, если Рома может выиграть на этом ходу и No, если нет.

#include <iostream>
#include <vector>

int main() {
    int n, a;
    std::cin >> n;
    std::vector<int> v(n);
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }
    for (int i = 0; i < n; i++) {
        std::cin >> a;
        v[i] -= a;
    }
    a = 0;
    for (int i = 0; i < n; i++) {
        if (v[i] > 0) {
            a += v[i] / 3;
        } else {
            a += v[i];
        }
    }
    if (a >= 0) {
        std::cout << "Yes";
    } else {
        std::cout << "No";
    }
}


B. Отсортируй массив
ограничение по времени на тест 1 s.
ограничение по памяти на тест 256 MB
Есть массив ai из n целых чисел. За один ход вы можете уменьшить один элемент массива на единицу.
Ваша задача — сделать массив отсортированным. Найдите минимальное количество ходов, которое вам нужно совершить.

Входные данные
Первая строка содержит число n (1≤n≤10^5). Вторая строка содержит n чисел ai (1≤ai≤10^9).

Выходные данные
Выведите одно число - минимальное количество ходов, которое вам нужно совершить.

#include <iostream>
#include <vector>

int main() {
    int n, a;
    long long sum;
    std::cin >> n;
    std::vector<int> v(n);
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }
    a = v[n - 1];
    sum = 0;
    for (int i = n - 2; i > -1; i--) {
        if (v[i] > a) {
            sum += v[i] - a;
        } else {
            a = v[i];
        }
    }
    std::cout << sum;
}


C. Лабиринт
ограничение по времени на тест2 s.
ограничение по памяти на тест512 MB
Лабиринт представляет собой прямоугольник размером n×m, разделённый на клетки. В каждой клетке находится стрелка.
Вы начинаете своё путешествие в нижнем левом углу. Когда вы стоите в клетке, вы движетесь в направлении стрелки.
Выход из лабиринта находится в правом верхнем углу.
Найдите количество шагов, которое вам нужно сделать, чтобы добраться до выхода.

Входные данные
Первая строка содержит числа n и m (1≤n,m≤100). Следующие n строк содержат по m символов каждая. Каждый символ
определяет направление стрелки: вправо >', влево <', вверх ˆ', и вниз v'. В правой верхней клетке находится символ '.'.

Выходные данные
Выведите количество шагов, необходимых для достижения правой верхней клетки, следуя стрелкам из нижнего левого угла.
Выведите −1, если пути не существует.

#include <iostream>
#include <vector>

int main() {
    int n, m, sum, a, b;
    std::cin >> n >> m;
    a = n - 1;
    b = 0;
    std::vector<std::vector<char>> v(n, std::vector<char>(m));
    std::vector<std::vector<int>> p(n, std::vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> v[i][j];
        }
    }
    sum = 0;
    for (int i = 0; i < n * m; i++) {
        if (v[a][b] == '^' && a > 0) {
            a -= 1;
            sum += 1;
        } else {
        if (v[a][b] == 'v' && a < n - 1) {
            a += 1;
            sum += 1;
        } else {
        if (v[a][b] == '>' && b < m - 1) {
            b += 1;
            sum += 1;
        } else {
        if (v[a][b] == '<' && b > 0) {
            b -= 1;
            sum += 1;
        } else {
            if (v[a][b] == '.') {
                std::cout << sum;
                a = -1;
            }
            break;

        }
        }
        }
        }
    }
    if (a != -1) {
        std::cout << -1;
    }
}


G. Ладья, слон и король
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
Маленький Петя учится играть в шахматы. Он уже выучил, как перемещаются король, ладья и слон.
Напомним и вам правила перемещения этих шахматных фигур. Шахматная доска представляет собой 64 квадратных поля,
выстроенных в таблицу 8×8. Поле обозначается парой целых чисел (r,c) — номером строки и номером столбца
(в классическом варианте столбцы обозначаются буквами). Каждая фигура занимает ровно одно поле.
Ход состоит в перемещении фигуры, причем фигуры перемещаются по следующим правилам:
-Ладья за один ход перемещается на произвольное количество клеток по горизонтали либо по вертикали.
-Слон за один ход перемещается на произвольное количество клеток по диагонали.
-Король за один ход перемещается на одно поле в любом направлении — горизонтально, вертикально, или по диагонали.

Петя раздумывает над следующей задачей: за какое наименьшее количество ходов каждая из этих фигур может переместиться
из поля (r1,c1) на поле (r2,c2)? При этом считается, что других фигур, кроме данной, на доске нет.
Помогите ему в решении этой задачи.

Входные данные
Во входных данных записаны четыре целых числа r1,c1,r2,c2 (1≤r1,c1,r2,c2≤8) — координаты стартового и конечного полей.
Стартовое поле не совпадает с конечным.
Можете считать, что строки шахматного поля нумеруются сверху вниз от 1 до 8, а столбцы слева направо от 1 до 8.

Выходные данные
Выведите три целых числа через пробел: наименьшее количество ходов, требуемых ладье, слону и королю (в таком порядке)
для того, чтобы переместиться из поля (r1,c1) на поле (r2,c2). В случае, если какая-то из фигур не может совершить
такое перемещение, выведите вместо соответствующего числа 0.

#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>

int main() {
    int x, y, x1, y1;
    std::cin >> x >> y >> x1 >> y1;
    if (x == x1 || y == y1) {
        std::cout << 1 << ' ';
    } else {
        std::cout << 2 << ' ';
    }
    if (abs(x - x1) == abs(y - y1)) {
        std::cout << 1 << ' ';
    } else {
        if ((x - x1 + y - y1) % 2 == 0) {
            std::cout << 2 << ' ';
        } else {
            std::cout << 0 << ' ';
        }
    }
    std::cout << std::max(abs(x - x1), abs(y - y1));
}


