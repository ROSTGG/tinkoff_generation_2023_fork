19. Кратчайшие пути: алгоритм Дейкстры


A. Алгоритм Дейкстры?
ограничение по времени на тест1 second
ограничение по памяти на тест256 МБ
Задан неориентированный взвешенный граф, вершины которого пронумерованы от 1 до n. Ваша задача найти кратчайший путь из вершины 1 в вершину n.

Входные данные
В первой строке содержатся целые числа n и m (2 ≤ n ≤ 10^5,0 ≤ m ≤ 10^5), где n — количество вершин,
а m — количество ребер в графе. Далее в m строках содержатся сами ребра, по одному в строке.
Каждое ребро задается тремя числами ai, bi, wi (1 ≤ ai, bi ≤ n, 1 ≤ wi ≤ 10^6),
где ai, bi — это концы ребра, а wi — его длина.

Граф может содержать кратные ребра и петли.

Выходные данные
Выведите число -1 если пути нет или сам кратчайший путь, если он существует.

#include <vector>
#include <iostream>
#include <map>
#include <set>

int main() {
    int n, m, na, a, b, c, con;
    long long infinite = 1e17;
    std::cin >> n >> m;
    na = 1;
    con = n;
    std::vector<std::vector<int>> v(m, std::vector<int>(3));
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b >> c;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
        v[i][2] = c;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], v[i][2]});
        v1[v[i][1]].push_back({v[i][0], v[i][2]});
    }
    na -= 1;
    con -= 1;
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    if (dist[con] != infinite) {
        while (con != -1) {
            x.push_back(con);
            con = rod[con];
        }
        for (int i = x.size() - 1; i >= 0; i--) {
            std::cout << x[i] + 1 << " ";
        }
    } else {
        std::cout << -1;
    }
}


C. Заправки
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
В стране N городов, некоторые из которых соединены между собой дорогами. Для того, чтобы проехать по одной дороге,
требуется один бак бензина. В каждом городе бак бензина имеет разную стоимость. Вам требуется добраться
из первого города в N-ый, потратив как можно меньшее денег. Покупать бензин впрок нельзя.

Входные данные
В первой строке вводится число N (1≤N≤100), в следующей строке идет N чисел, i-ое из которых задает стоимость бензина
в i-ом городе (всё это целые числа из диапазона от 0 до 100).

Затем идет число M — количество дорог в стране, далее идет описание самих дорог.
Каждая дорога задается двумя числами — номерами городов, которые она соединяет.
Все дороги двухсторонние (то есть по ним можно ездить как в одну, так и в другую сторону),
между двумя городами всегда существует не более одной дороги, не существует дорог, ведущих из города в себя.

Выходные данные
Требуется вывести одно число — суммарную стоимость маршрута или −1, если добраться невозможно.

#include <vector>
#include <iostream>
#include <map>
#include <set>

int main() {
    int n, m, na, a, b, con;
    long long infinite = 1e17;
    std::cin >> n;
    na = 1;
    con = n;
    std::vector<int> vv(n);
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < n; i++) {
        std::cin >> a;
        vv[i] = a;
    }
    std::cin >> m;
    std::vector<std::vector<int>> v(m, std::vector<int>(2));
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], vv[v[i][0]]});
        v1[v[i][1]].push_back({v[i][0], vv[v[i][1]]});
    }
    na -= 1;
    con -= 1;
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    if (dist[con] != infinite) {
        std::cout << dist[con];
    } else {
        std::cout << -1;
    }
}


D. Олимпиада по алхимии
ограничение по времени на тест 1 секунда
ограничение по памяти на тест 256 мегабайт
В государстве алхимиков есть N населённых пунктов, пронумерованных числами от 1 до N, и M дорог.
Населённые пункты бывают двух типов: деревни и города. Кроме того, в государстве есть одна столица
(она может располагаться как в городе, так и в деревне). Каждая дорога соединяет два населённых пункта, и для проезда
по ней требуется Ti минут. В столице было решено провести 1-ю государственную командную олимпиаду по алхимии.
Для этого во все города из столицы были отправлены гонцы (по одному гонцу на город) с информацией про олимпиаду.

Напишите программу, которая посчитает, в каком порядке и через какое время каждый из гонцов доберётся до своего города.
Считается, что гонец во время пути не спит и нигде не задерживается.

Входные данные
Во входном файле сначала записаны 3 числа N, M, K — количество населенных пунктов, количество дорог
и количество городов (2≤N≤1000, 1≤M≤10000, 1≤K≤N). Далее записан номер столицы C (1≤C≤N).

Следующие K чисел задают номера городов.

Далее следуют M троек чисел Si, Ei, Ti, описывающих дороги: Si и Ei — номера населенных пунктов,
которые соединяет данная дорога, а Ti — время для проезда по ней (1≤Ti≤100).

Гарантируется, что до каждого города из столицы можно добраться по дорогам (возможно, через другие населенные пункты).

Выходные данные
Выведите в выходной файл K пар чисел: для каждого города должен быть выведен его номер и минимальное время,
когда гонец может в нем оказаться (время измеряется в минутах с того момента, как гонцы выехали из столицы).
Пары в выходном файле должны быть упорядочены по времени прибытия гонца.

#include <vector>
#include <iostream>
#include <map>
#include <set>
#include <algorithm>

int main() {
    int n, m, na, a, b, c, k;
    long long infinite = 1e17;
    std::cin >> n >> m >> k >> na;
    na -= 1;
    std::vector<std::vector<int>> v(m, std::vector<int>(3)), otv(k, std::vector<int>(3));
    std::vector<std::vector<std::pair<int, int>>> v1(n);
    std::vector<long long> rod(n, -1), x, dist(n, infinite);
    std::set<std::pair<int, int>> q;
    for (int i = 0; i < k; i++) {
        std::cin >> a;
        otv[i][1] = a - 1;
    }
    for (int i = 0; i < m; i++) {
        std::cin >> a >> b >> c;
        v[i][0] = a - 1;
        v[i][1] = b - 1;
        v[i][2] = c;
    }
    for (int i = 0; i < m; i++) {
        v1[v[i][0]].push_back({v[i][1], v[i][2]});
        v1[v[i][1]].push_back({v[i][0], v[i][2]});
    }
    dist[na] = 0;
    q.insert({dist[na], na});
    while (!q.empty()) {
        a = q.begin()->second;
        q.erase(q.begin());
        for (int i = 0; i < v1[a].size(); i++) {
            if (dist[v1[a][i].first] > dist[a] + v1[a][i].second) {
                q.erase({dist[v1[a][i].first], v1[a][i].first});
                dist[v1[a][i].first] = dist[a] + v1[a][i].second;
                q.insert({dist[v1[a][i].first], v1[a][i].first});
                rod[v1[a][i].first] = a;
            }
        }
    }
    for (int i = 0; i < k; i++) {
        otv[i][0] = dist[otv[i][1]];
    }
    std::sort(begin(otv), end(otv));
    for (int i = 0; i < k; i++) {
        std::cout << otv[i][1] + 1 << " " << otv[i][0] << '\n';
    }
}

--------------------------------------------------------------

